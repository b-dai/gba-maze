#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/resizedGarbage.h"
#include "images/startScreen.h"
#include "images/lostScreen.h"
#include "images/lostAnywayScreen.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  INIT_PLAY,
  PLAY,
  LOSE,
  LOSE_ANYWAY,
};

struct wall gameWalls[100];

void createWalls(void) {
  for (int i = 0; i < 100; i++) {
    struct wall newWall = {0, 0, 0, 0};
    gameWalls[i] = newWall;
  }
  struct wall w1 = {0, 38, 80, 4};
  gameWalls[0] = w1;
  struct wall w2 = {38, 78, 4, 40};
  gameWalls[1] = w2;
  struct wall w3 = {78, 0, 4, 80};
  gameWalls[2] = w3;
  struct wall w4 = {118, 38, 4, 40};
  gameWalls[3] = w4;
  struct wall w5 = {118, 38, 80, 4};
  gameWalls[4] = w5;
  struct wall w6 = {198, 78, 42, 4};
  gameWalls[5] = w6;
  struct wall w7 = {158, 38, 4, 80};
  gameWalls[6] = w7;
  struct wall w8 = {38, 118, 160, 4};
  gameWalls[7] = w8;
  struct wall w9 = {118, 118, 4, 42};
  gameWalls[8] = w9;
}

void clearWalls(void) {
  for (int i = 0; i < 100; i++) {
    struct wall newWall = {0, 0, 0, 0};
    gameWalls[i] = newWall;
  }
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  struct player user = {0, 0, 95, 135, 10, 10};
  struct zone zone = {122, 122, 38, 38};
  struct state cs = {user, zone};
  struct state ps;
  int time = 7;
  u32 prevVBlankCount;

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons
    ps = cs;
    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = INIT_PLAY;
        }
        break;
      case INIT_PLAY:
        break;
      case PLAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          clearWalls();
          struct player newUser = {0, 0, 95, 135, 10, 10};
          struct zone newZone = {122, 122, 38, 38};
          struct state newcs = {newUser, newZone};
          cs = newcs;
          ps = cs;
          time = 7;
        } else {
          if (time <= 0) {
            state = LOSE;
            clearWalls();
            struct player newUser = {0, 0, 95, 135, 10, 10};
            struct zone newZone = {122, 122, 38, 38};
            struct state newcs = {newUser, newZone};
            cs = newcs;
            ps = cs;
            time = 7;
          }
          if (KEY_DOWN(BUTTON_UP, currentButtons) != 0) {
            cs.player.dY = -2;
          } else if (KEY_DOWN(BUTTON_DOWN, currentButtons) != 0) {
            cs.player.dY = 2;
          } else {
            cs.player.dY = 0;
          }
          cs.player.y += cs.player.dY;
          if (cs.player.y < 0) {
            cs.player.y = 0;
          } else if (cs.player.y + cs.player.height > HEIGHT) {
            cs.player.y = HEIGHT - cs.player.height;
          }
          for (int i = 0; i < 9; i++) {
            if (cs.player.x + cs.player.width > gameWalls[i].x && cs.player.x < gameWalls[i].x + gameWalls[i].width) {
              if (cs.player.dY > 0 && cs.player.y + cs.player.height > gameWalls[i].y && cs.player.y < gameWalls[i].y + gameWalls[i].height) {
                cs.player.y = gameWalls[i].y - cs.player.height;
              } else if (cs.player.dY < 0 && cs.player.y < gameWalls[i].y + gameWalls[i].height && cs.player.y + cs.player.height > gameWalls[i].y) {
                cs.player.y = gameWalls[i].y + gameWalls[i].height;
              }
            }
          }

          if (KEY_DOWN(BUTTON_LEFT, currentButtons) != 0) {
            cs.player.dX = -2;
          } else if (KEY_DOWN(BUTTON_RIGHT, currentButtons) != 0) {
            cs.player.dX = 2;
          } else {
            cs.player.dX = 0;
          }
          cs.player.x += cs.player.dX;
          if (cs.player.x < 0) {
            cs.player.x = 0;
          } else if (cs.player.x + cs.player.width > WIDTH) {
            cs.player.x = WIDTH - cs.player.width;
          }
          for (int i = 0; i < 9; i++) {
            if (cs.player.y < gameWalls[i].y + gameWalls[i].height && cs.player.y + cs.player.height > gameWalls[i].y) {
              if (cs.player.dX > 0 && cs.player.x + cs.player.width > gameWalls[i].x && cs.player.x < gameWalls[i].x + gameWalls[i].width) {
                cs.player.x = gameWalls[i].x - cs.player.width;
              } else if (cs.player.dX < 0 && cs.player.x < gameWalls[i].x + gameWalls[i].width && cs.player.x + cs.player.width > gameWalls[i].x) {
                cs.player.x = gameWalls[i].x + gameWalls[i].width;
              }
            }
          }
          if (cs.player.y < cs.endZone.y + cs.endZone.height && cs.player.y + cs.player.height > cs.endZone.y && cs.player.x + cs.player.width > cs.endZone.x && cs.player.x < cs.endZone.x + cs.endZone.width) {
            state = LOSE_ANYWAY;
            clearWalls();
            struct player newUser = {0, 0, 95, 135, 10, 10};
            struct zone newZone = {122, 122, 38, 38};
            struct state newcs = {newUser, newZone};
            cs = newcs;
            ps = cs;
            time = 7;
          }
        }
        break;
      case LOSE:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          clearWalls();
          struct player newUser = {0, 0, 95, 135, 10, 10};
          struct zone newZone = {122, 122, 38, 38};
          struct state newcs = {newUser, newZone};
          cs = newcs;
          ps = cs;
          time = 7;
        }
        break;
      case LOSE_ANYWAY:
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
          clearWalls();
          struct player newUser = {0, 0, 95, 135, 10, 10};
          struct zone newZone = {122, 122, 38, 38};
          struct state newcs = {newUser, newZone};
          cs = newcs;
          ps = cs;
          time = 7;
        }
        break;
    }

    waitForVBlank();

    switch (state) {
      case START:
        drawFullScreenImageDMA(startScreen);
        break;
      case INIT_PLAY:
        prevVBlankCount = vBlankCounter;
        createWalls();
        fillScreenDMA(YELLOW);
        for (int i = 0; i < 9; i++) {
          drawRectDMA(gameWalls[i].y, gameWalls[i].x, gameWalls[i].width, gameWalls[i].height, BLACK);
        }
        drawRectDMA(cs.endZone.y, cs.endZone.x, cs.endZone.width, cs.endZone.height, GREEN);
        state = PLAY;
        break;
      case PLAY:
        if (vBlankCounter - prevVBlankCount >= 60) {
          time--;
          prevVBlankCount = vBlankCounter;
        }
        drawRectDMA(10, 30, 20, 20, YELLOW);
        drawChar(15, 35, time + 48, BLACK);
        drawRectDMA(ps.player.y, ps.player.x, ps.player.width, ps.player.height, YELLOW);
        drawImageDMA(cs.player.y, cs.player.x, cs.player.width, cs.player.height, resizedGarbage);
        break;
      case LOSE:
        drawFullScreenImageDMA(lostScreen);
        break;
      case LOSE_ANYWAY:
        drawFullScreenImageDMA(lostAnywayScreen);
        break;
    }
    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
